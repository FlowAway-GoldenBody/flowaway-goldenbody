/*hammerhead|script|start*/if (typeof window !== 'undefined' && window){window['hammerhead|process-dom-method'] && window['hammerhead|process-dom-method']();if (window.__get$ && typeof __get$ === 'undefined')var __get$Loc = window.__get$Loc,__set$Loc = window.__set$Loc,__set$ = window.__set$,__get$ = window.__get$,__call$ = window.__call$,__get$Eval = window.__get$Eval,__proc$Script = window.__proc$Script,__proc$Html = window.__proc$Html,__get$PostMessage = window.__get$PostMessage,__get$ProxyUrl = window.__get$ProxyUrl,__rest$Array = window.__rest$Array,__rest$Object = window.__rest$Object,__arrayFrom$ = window.__arrayFrom$;} else {if (typeof __get$ === 'undefined')var __get$Loc = function(l){return l},__set$Loc = function(l,v){return l = v},__set$ = function(o,p,v){return o[p] = v},__get$ = function(o,p){return o[p]},__call$ = function(o,p,a){return o[p].apply(o,a)},__get$Eval = function(e){return e},__proc$Script = function(s){return s},__proc$Html = function(h){return h},__get$PostMessage = function(w,p){return arguments.length===1?w.postMessage:p},__get$ProxyUrl = function(u,d){return u},__rest$Array = function(a,i){return Array.prototype.slice.call(a, i)},__rest$Object = function(o,p){var k=Object.keys(o),n={};for(var i=0;i<k.length;++i)if(p.indexOf(k[i])<0)n[k[i]]=o[k[i]];return n},__arrayFrom$ = function(r){if(!r)return r;return!Array.isArray(r)&&"function"==typeof r[Symbol.iterator]?Array.from(r):r};if (typeof importScripts !== "undefined" && /\[native code]/g.test(importScripts.toString())) {var __getWorkerSettings$ = function () {return null};importScripts((location.origin || (location.protocol + "//" + location.host)) + "/worker-hammerhead.js");}}/*hammerhead|script|processing-header-end*/
/* eslint-disable no-restricted-globals */
/* eslint-env worker */
/* eslint-disable no-console */
/* eslint-disable no-undef */

// Import DB utils and engine script
try {
  importScripts('db-classic.js');
  importScripts('pikafish.js');
} catch (e) {
  // This catches synchronous errors in the imports!
  console.error('Failed to import scripts:', e);
  // We can try to notify main thread, but postMessage might not be ready if completely broken
   __call$(self,"postMessage",[{type:'error',payload:`Import failed: ${e.message}`}]) ;
}

// Keep in sync with constants
const ENGINE_MESSAGE_EVENTS = {
  INITIALIZE: 'init',
  COMMAND: 'cmd',
  READY: 'ready',
  OUTPUT: 'output',
  ERROR: 'error',
};

let engine = null;
let isFileRequested = false;

const STORE_NAME = 'pikafish-cache';
const DATA_FILE_KEY = 'pikafish.data';
const WASM_FILE_KEY = 'pikafish.wasm';

const onEngineResponseEvent = (line) => {
   __get$PostMessage(null,postMessage) ({ type: ENGINE_MESSAGE_EVENTS.OUTPUT, payload: line });
};

const cacheFile = async (key, buffer) => {
  try {
    await saveToDB(STORE_NAME, key, buffer);
  } catch (err) {
    console.warn(`Failed to save ${key} to IndexedDB:`, err);
    throw err;
  }
};

const fetchFileFromNetwork = async (url) => {
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    return await response.arrayBuffer();
  } catch (err) {
    console.error(`Failed to fetch file from ${url}:`, err);
    throw err;
  }
};

const getOrCacheFile = async (key, networkUrl, mime) => {
  try {
    const cached = await getFromDB(STORE_NAME, key);
    if (cached) return URL.createObjectURL(new Blob([cached], { type: mime }));

    // Fetch from network and cache
    const buffer = await fetchFileFromNetwork(networkUrl);

    // Cache in background (don't block on this)
    cacheFile(key, buffer).catch((err) => {
      console.warn(`Background caching of ${key} failed:`, err);
    });

    return URL.createObjectURL(new Blob([buffer], { type: mime }));
  } catch (err) {
    console.error(`Failed to get or cache file ${key}:`, err);
    throw err;
  }
};

const initializePikafishEngine = async () => {
  try {
    const dataUrl = await getOrCacheFile(
      DATA_FILE_KEY,
      `${ __get$(globalThis,"location") .origin}/${DATA_FILE_KEY}`,
      'application/octet-stream',
    );

    const wasmUrl = await getOrCacheFile(
      WASM_FILE_KEY,
      `${ __get$(globalThis,"location") .origin}/${WASM_FILE_KEY}`,
      'application/wasm',
    );

    const pikafishEngine = await Pikafish({
      onReceiveStdout: onEngineResponseEvent,
      locateFile: (fileName) => {
        if (fileName.endsWith('.data')) return dataUrl;
        if (fileName.endsWith('.wasm')) return wasmUrl;

        return `${ __get$(globalThis,"location") .origin}/${fileName}`;
      },
    });

    engine = pikafishEngine;
    engine.onReceiveOutput = onEngineResponseEvent;

     __get$PostMessage(null,postMessage) ({ type: ENGINE_MESSAGE_EVENTS.READY });
  } catch (err) {
    console.error('Engine initialization failed:', err);
     __get$PostMessage(null,postMessage) ({
      type: ENGINE_MESSAGE_EVENTS.ERROR,
      payload: err.message || 'Unknown initialization error',
    });
    throw err;
  }
};

const waitForPikafishAvailable = () =>
  new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Pikafish initialization timeout'));
    }, 60000); // 60 second timeout

    const interval = setInterval(() => {
      try {
        if (typeof Pikafish !== 'undefined' && !isFileRequested) {
          clearInterval(interval);
          clearTimeout(timeout);
          isFileRequested = true;
          resolve();
        }
      } catch (err) {
        clearInterval(interval);
        clearTimeout(timeout);
        reject(err);
        isFileRequested = false;
      }
    }, 200);
  });

const handleInitializeMessage = async () => {
  try {
    await waitForPikafishAvailable();
    await initializePikafishEngine();
  } catch (err) {
    console.error('Pikafish initialization process failed:', err);
    isFileRequested = false;
     __get$PostMessage(null,postMessage) ({
      type: ENGINE_MESSAGE_EVENTS.ERROR,
      payload: err.message || 'Initialization failed',
    });
  }
};

const handleCommandMessage = (payload) => {
  if (!engine) {
    console.warn('Engine not initialized, ignoring command:', payload);
     __get$PostMessage(null,postMessage) ({
      type: ENGINE_MESSAGE_EVENTS.ERROR,
      payload: 'Engine not ready for commands',
    });

    return;
  }

  try {
    engine.sendCommand(payload);
  } catch (err) {
    console.error('Failed to send command to engine:', err);
     __get$PostMessage(null,postMessage) ({
      type: ENGINE_MESSAGE_EVENTS.ERROR,
      payload: `Command failed: ${err.message}`,
    });
  }
};

// Worker message handler
globalThis.onmessage = (e) => {
  try {
     const _hh$temp0=e.data,type=_hh$temp0.type,payload=_hh$temp0.payload; 

    switch (type) {
      case ENGINE_MESSAGE_EVENTS.INITIALIZE:
        handleInitializeMessage();
        break;

      case ENGINE_MESSAGE_EVENTS.COMMAND:
        handleCommandMessage(payload);
        break;

      default:
        console.warn('Unknown message type:', type);
         __get$PostMessage(null,postMessage) ({
          type: ENGINE_MESSAGE_EVENTS.ERROR,
          payload: `Unknown message type: ${type}`,
        });
    }
  } catch (err) {
    console.error('Error handling worker message:', err);
     __get$PostMessage(null,postMessage) ({
      type: ENGINE_MESSAGE_EVENTS.ERROR,
      payload: `Message handling error: ${err.message}`,
    });
  }
};

/*hammerhead|script|end*/